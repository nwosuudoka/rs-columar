use quote::quote;
use syn::{Ident, Path, Type};

pub struct FieldSpec {
    pub field_ident: Ident,
    pub field_ty: Type,
    pub column_ident: Path,
    pub fattrs: crate::attr::FieldAttrs,
}

/// Generates a struct definition for a columnar struct, given
/// the fields that should be included in the struct.
///
/// The `vis` parameter controls the visibility of the generated struct.
/// The `columns_ident` parameter is the identifier to use for the generated
/// struct. The `fields` parameter is an iterator of `FieldSpec` objects,
/// each of which contains the information needed to generate a single field
/// in the struct. The `backend_ty_for` parameter is a closure that takes
/// a `FieldSpec` and returns a `TokenStream` representing the type
/// of the field. The `derives` parameter is an iterator of strings, each of
/// which is the name of a trait that the generated struct should derive.
///
/// The generated struct will have the same visibility as `vis`, and will have
/// the same identifier as `columns_ident`. The struct will have fields for
/// each of the `FieldSpec` objects in `fields`, with the type of each field
/// generated by calling `backend_ty_for` with the corresponding `FieldSpec`.
/// The struct will also derive the traits named in `derives`.
pub fn make_column_struct(
    vis: &syn::Visibility,
    columns_ident: &Ident,
    fields: &[FieldSpec],
    backend_ty_for: &dyn Fn(&FieldSpec) -> proc_macro2::TokenStream,
    derives: &[&str],
) -> proc_macro2::TokenStream {
    let derived = {
        let list = derives
            .iter()
            .map(|d| syn::Ident::new(d, proc_macro2::Span::call_site()));
        quote! { #[derive(#(#list),*)] }
    };

    let cols = fields.iter().filter(|f| !f.fattrs.skip).map(|f| {
        let col_ident = &f.column_ident;
        let ty = backend_ty_for(f);
        quote! {
            pub #col_ident: #ty,
        }
    });

    quote! {
        #derived
        #vis struct #columns_ident {
            #(#cols)*
        }
    }
}

pub fn push_impl_body(fields: &[FieldSpec]) -> proc_macro2::TokenStream {
    let stmts = fields.iter().filter(|f| !f.fattrs.skip).map(|f| {
        let fi = &f.field_ident;
        let ci = &f.column_ident;
        quote! {
            self.#ci.push(&row.#fi.clone());
        }
    });

    quote! {
        #(#stmts)*
    }
}

pub fn merge_impl_body(fields: &[FieldSpec]) -> proc_macro2::TokenStream {
    let stmts = fields.iter().filter(|f| !f.fattrs.skip).map(|f| {
        let ci = &f.column_ident;
        quote! {
            self.#ci.merge(other.#ci);
        }
    });
    quote! {
        #(#stmts)*
    }
}

// When you add a new backend, provide a new backend_ty_for() function that maps a field to a runtime type (e.g., Vec<T>, Column<T>, StreamColumn<T>).
